<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Office Uprising</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        body {
            background-color: #f3f4f6; /* cinza claro de fundo */
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        canvas {
            cursor: pointer;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .ui-panel {
            background-color: #fff;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        .tower-card.selected, .tower-card:hover {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }
        .tower-card {
            transition: all 0.2s ease-in-out;
            border: 2px solid transparent;
        }
        .modal {
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .modal-hidden {
            opacity: 0;
            transform: scale(0.95);
            pointer-events: none;
        }
        .tower-card-img {
            width: 48px;
            height: 48px;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
        }
    </style>
</head>
<body class="flex flex-col xl:flex-row items-center justify-center min-h-screen p-4 gap-4">

    <!-- Painel de UI -->
    <div class="ui-panel w-full xl:w-96 p-5 flex-shrink-0 order-2 xl:order-1 self-stretch flex flex-col">
        <h1 class="text-3xl font-bold text-gray-800 text-center mb-4">OFFICE UPRISING</h1>
        
        <!-- Status do Jogo -->
        <div class="grid grid-cols-3 gap-3 text-center mb-4">
            <div class="bg-gray-100 p-2 rounded-lg">
                <div class="text-sm font-semibold text-gray-500">üìé Clipes</div>
                <div id="staples-amount" class="text-xl font-bold text-gray-800">200</div>
            </div>
            <div class="bg-gray-100 p-2 rounded-lg">
                <div class="text-sm font-semibold text-red-500">‚òïÔ∏è Pausas</div>
                <div id="health-amount" class="text-xl font-bold text-red-600">20</div>
            </div>
             <div class="bg-gray-100 p-2 rounded-lg">
                <div class="text-sm font-semibold text-blue-500">üåä Onda</div>
                <div id="wave-number" class="text-xl font-bold text-blue-600">0</div>
            </div>
        </div>
        
        <!-- Torres para Comprar -->
        <div id="tower-shop">
            <h2 class="text-lg font-semibold text-gray-700 mb-2">Defesas</h2>
            <div id="tower-selection" class="space-y-2"></div>
        </div>

        <!-- Painel de Upgrade (din√¢mico) -->
        <div id="upgrade-panel" class="hidden mt-4 pt-4 border-t">
            <h2 id="upgrade-tower-name" class="text-lg font-semibold text-gray-700 mb-2"></h2>
            <p class="text-sm text-gray-500 mb-2">N√≠vel: <span id="upgrade-tower-level"></span></p>
            <p class="text-sm text-gray-500 mb-3">Dano: <span id="upgrade-tower-damage"></span> | Alcance: <span id="upgrade-tower-range"></span></p>
            <button id="upgrade-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition"></button>
            <button id="sell-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition mt-2"></button>
        </div>

        <div class="flex-grow"></div>
        <div class="flex gap-2 mt-4">
            <button id="start-wave-btn" class="w-full bg-green-500 hover:bg-green-600 text-white text-xl font-bold py-3 rounded-lg shadow-md transition-transform transform hover:scale-105">INICIAR ONDA</button>
            <div class="flex-shrink-0 flex gap-2">
                <button id="pause-btn" class="w-12 bg-gray-500 hover:bg-gray-600 text-white text-2xl font-bold py-3 rounded-lg shadow-md" disabled>‚è∏Ô∏è</button>
                <button id="speed-btn" class="w-12 bg-indigo-500 hover:bg-indigo-600 text-white text-xl font-bold py-3 rounded-lg shadow-md">1x</button>
                <button id="mute-btn" class="w-12 bg-yellow-500 hover:bg-yellow-600 text-white text-2xl font-bold py-3 rounded-lg shadow-md">üîä</button>
            </div>
        </div>
    </div>

    <!-- √Årea do Jogo -->
    <div class="relative order-1 xl:order-2">
        <canvas id="gameCanvas" width="880" height="640"></canvas>
        <div id="modal" class="modal modal-hidden absolute inset-0 bg-black bg-opacity-75 flex flex-col items-center justify-center text-white text-center p-8 rounded-lg">
            <h2 id="modal-title" class="text-5xl font-bold mb-4"></h2>
            <div id="modal-content" class="text-lg mb-6 whitespace-pre-wrap"></div>
            <div id="modal-buttons"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ---------- Offscreen Canvas for Pre-rendering Background ----------
        const bgCanvas = document.createElement('canvas');
        const bgCtx = bgCanvas.getContext('2d');
        bgCanvas.width = canvas.width;
        bgCanvas.height = canvas.height;

        // ---------- ASSETS & AUDIO SETUP ----------
        const ASSETS = { towers: {}, enemies: {} };
        const audio = { ready: false, muted: false, synths: {}, music: null, lastHitSoundTime: 0, hitSoundInterval: 0.05 };
        const TILE_SIZE = 40;
        const TOWER_RADIUS = TILE_SIZE / 2 - 2;

        // ---------- HELPER FUNCTIONS ----------
        function createSvgImage(svg) { const img = new Image(); img.src = 'data:image/svg+xml;base64,' + btoa(svg); return img; }
        function clamp(value, min, max) { return Math.max(min, Math.min(value, max)); }
        function pointSegmentDistance(px, py, x1, y1, x2, y2) {
            const l2 = (x2 - x1) ** 2 + (y2 - y1) ** 2;
            if (l2 === 0) return Math.hypot(px - x1, py - y1);
            let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
            t = Math.max(0, Math.min(1, t));
            return Math.hypot(px - (x1 + t * (x2 - x1)), py - (y1 + t * (y2 - y1)));
        }

        // ---------- ASSET DEFINITIONS ----------
        function defineAssets() {
            ASSETS.towers.tack = [
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,20)"><circle r="16" fill="#d1d5db"/><path d="M0 -14 L-4 4 L4 4 Z" fill="#ef4444"/><circle cy="-15" r="5" fill="#f87171"/></g></svg>`),
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,20)"><circle r="17" fill="#9ca3af"/><g><path d="M0 -15 L-4 4 L4 4 Z" fill="#ef4444"/><circle cy="-16" r="5" fill="#f87171"/></g><g transform="rotate(120)"><path d="M0 -15 L-4 4 L4 4 Z" fill="#ef4444"/><circle cy="-16" r="5" fill="#f87171"/></g><g transform="rotate(240)"><path d="M0 -15 L-4 4 L4 4 Z" fill="#ef4444"/><circle cy="-16" r="5" fill="#f87171"/></g></g></svg>`),
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,20)"><circle r="18" fill="#4b5563"/><g><path d="M0 -16 L-5 5 L5 5 Z" fill="#dc2626"/><circle cy="-17" r="6" fill="#ef4444"/></g><g transform="rotate(72)"><path d="M0 -16 L-5 5 L5 5 Z" fill="#dc2626"/><circle cy="-17" r="6" fill="#ef4444"/></g><g transform="rotate(144)"><path d="M0 -16 L-5 5 L5 5 Z" fill="#dc2626"/><circle cy="-17" r="6" fill="#ef4444"/></g><g transform="rotate(216)"><path d="M0 -16 L-5 5 L5 5 Z" fill="#dc2626"/><circle cy="-17" r="6" fill="#ef4444"/></g><g transform="rotate(288)"><path d="M0 -16 L-5 5 L5 5 Z" fill="#dc2626"/><circle cy="-17" r="6" fill="#ef4444"/></g></g></svg>`)
            ];
            ASSETS.towers.stapler = [
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,18)"><path d="M-15 5 H15 V10 H-15 Z" fill="#6b7280"/><path d="M-15 -5 H12 L15 5 H-15 Z" fill="#9ca3af"/><rect x="-13" y="-3" width="18" height="6" fill="#d1d5db"/></g></svg>`),
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,18)"><path d="M-17 6 H17 V12 H-17 Z" fill="#374151"/><path d="M-17 -6 H14 L17 6 H-17 Z" fill="#6b7280"/><rect x="-15" y="-4" width="22" height="8" fill="#9ca3af"/><circle cx="12" cy="-2" r="2" fill="#ef4444"/></g></svg>`),
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,18)"><path d="M-18 7 H18 V14 H-18 Z" fill="#111827"/><path d="M-18 -7 H15 L18 7 H-18 Z" fill="#4b5563"/><rect x="-16" y="-5" width="25" height="10" fill="#6b7280"/><path d="M10 -5 H15 V5 H10 Z" fill="#ef4444"/><rect x="-16" y="-1" width="3" height="3" fill="#facc15"/></g></svg>`)
            ];
            ASSETS.towers.highlighter = [
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,20) rotate(45)"><rect x="-5" y="-18" width="10" height="25" rx="3" fill="#f0fdf4"/><rect x="-5" y="7" width="10" height="8" rx="3" fill="#d1d5db"/><path d="M-5 -18 H5 L0 -24 Z" fill="#fef08a"/></g></svg>`),
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,20) rotate(45)"><rect x="-6" y="-18" width="12" height="26" rx="4" fill="#dcfce7"/><rect x="-6" y="8" width="12" height="9" rx="4" fill="#9ca3af"/><path d="M-6 -18 H6 L0 -25 Z" fill="#fde047"/><circle r="3" fill="#a3e635"/></g></svg>`),
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,20) rotate(45)"><rect x="-7" y="-20" width="14" height="28" rx="5" fill="#bbf7d0"/><rect x="-7" y="8" width="14" height="10" rx="5" fill="#6b7280"/><path d="M-7 -20 H7 L0 -28 Z" fill="#facc15"/><path d="M-2 -5 H2 V5 H-2 Z" fill="#a3e635"/><path d="M-5 -2 H5 V2 H-5 Z" fill="#a3e635"/></g></svg>`)
            ];
            ASSETS.towers.rubber_band = [
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,20)"><circle r="12" fill="#f59e0b"/><circle r="10" stroke="#fcd34d" stroke-width="2" fill="none" transform="rotate(45)"/><circle r="8" stroke="#fbbf24" stroke-width="2" fill="none"/></g></svg>`),
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,20)"><circle r="15" fill="#f59e0b"/><circle r="13" stroke="#fcd34d" stroke-width="2.5" fill="none" transform="rotate(45)"/><circle r="10" stroke="#fbbf24" stroke-width="2.5" fill="none"/><circle r="7" stroke="#fde047" stroke-width="2.5" fill="none" transform="rotate(-30)"/></g></svg>`),
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,20)"><circle r="18" fill="#d97706"/><circle r="16" stroke="#fcd34d" stroke-width="3" fill="none" transform="rotate(45)"/><circle r="13" stroke="#fbbf24" stroke-width="3" fill="none"/><circle r="10" stroke="#fde047" stroke-width="3" fill="none" transform="rotate(-30)"/><circle r="7" stroke="#fef08a" stroke-width="3" fill="none" transform="rotate(15)"/></g></svg>`)
            ];
            ASSETS.towers.calculator = [
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,20) rotate(45)"><rect x="-10" y="-16" width="20" height="32" rx="3" fill="#4b5563"/><rect x="-8" y="-14" width="16" height="10" fill="#dcfce7"/><circle cy="10" r="8" fill="#ef4444"/><circle cy="10" r="3" fill="#fee2e2"/></g></svg>`),
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,20) rotate(45)"><rect x="-11" y="-17" width="22" height="34" rx="4" fill="#1f2937"/><rect x="-9" y="-15" width="18" height="12" fill="#bbf7d0"/><rect x="-9" y="-2" width="18" height="4" fill="#374151"/><circle cy="12" r="9" fill="#dc2626"/><circle cy="12" r="4" fill="#fecaca"/></g></svg>`),
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,20) rotate(45)"><rect x="-12" y="-18" width="24" height="36" rx="5" fill="#111827"/><rect x="-10" y="-16" width="20" height="14" fill="#a7f3d0"/><rect x="-10" y="-1" width="20" height="5" fill="#1f2937"/><path d="M-10 6 H10 V18 H-10 Z" fill="#374151"/><circle cy="13" r="10" fill="#b91c1c"/><circle cy="13" r="5" fill="#fca5a5"/></g></svg>`)
            ];

            ASSETS.enemies.bug = createSvgImage('<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2a10 10 0 100 20 10 10 0 000-20z" fill="#22c55e"/><path d="M12 2v20" stroke="#166534" stroke-width="1"/><path d="M9.5 8a1.5 1.5 0 11-3 0 1.5 1.5 0 013 0zm5 0a1.5 1.5 0 11-3 0 1.5 1.5 0 013 0z" fill="#14532d"/><path d="M7 14s-2 2-4 2m14-2s2 2 4 2M7 10s-2-2-4-2m14 2s2-2 4-2" stroke="#14532d" stroke-width="1.5" fill="none" stroke-linecap="round"/></svg>');
            ASSETS.enemies.glitch = createSvgImage('<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M4 4H20V20H4z" fill="#8b5cf6"/><rect x="6" y="9" width="4" height="6" fill="#fff"/><rect x="14" y="9" width="4" height="6" fill="#fff"/><rect x="7" y="10" width="2" height="4" fill="#000"/><rect x="15" y="10" width="2" height="4" fill="#000"/></svg>');
            ASSETS.enemies.crash = createSvgImage('<svg viewBox="0 0 36 36" xmlns="http://www.w3.org/2000/svg"><circle cx="18" cy="18" r="14" fill="#f97316"/><path d="M10 12 L26 28 M10 28 L26 12" stroke="#9a3412" stroke-width="4"/><circle cx="15" cy="15" r="3" fill="#fff"/><circle cx="21" cy="15" r="3" fill="#fff"/><circle cx="15" cy="15" r="1.5" fill="#000"/><circle cx="21" cy="15" r="1.5" fill="#000"/></svg>');
            ASSETS.enemies.boss = createSvgImage('<svg viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg"><path d="M25 2 C12 2 2 12 2 25 C2 38 12 48 25 48 S48 38 48 25 C48 12 38 2 25 2Z" fill="#be123c"/><path d="M15 15 L22 25 L15 35 M35 15 L28 25 L35 35" stroke="#fff" stroke-width="4" fill="none"/><circle cx="25" cy="25" r="5" fill="#fca5a5"/><circle cx="25" cy="25" r="2" fill="#991b1b"/></svg>');
        }

        function preloadAssets(callback) {
            const assetsToLoad = [];
            for (const type in ASSETS.towers) {
                ASSETS.towers[type].forEach(img => assetsToLoad.push(img));
            }
            for (const type in ASSETS.enemies) {
                assetsToLoad.push(ASSETS.enemies[type]);
            }

            if (assetsToLoad.length === 0) {
                callback();
                return;
            }

            let loadedCount = 0;
            assetsToLoad.forEach(asset => {
                if (asset.complete && asset.naturalHeight !== 0) {
                    loadedCount++;
                } else {
                    asset.onload = () => {
                        loadedCount++;
                        if (loadedCount === assetsToLoad.length) callback();
                    };
                    asset.onerror = () => { 
                        console.error("Falha ao carregar asset:", asset.src);
                        loadedCount++;
                        if (loadedCount === assetsToLoad.length) callback();
                    }
                }
            });
             if (loadedCount === assetsToLoad.length) callback();
        }

        // --- GAME STATE & CONFIG ---
        let gameState = {
            staples: 200, health: 20, wave: 0, mapIndex: 0, status: 'START',
            enemies: [], towers: [], projectiles: [],
            selectedTowerToPlace: null, selectedPlacedTower: null,
            waveInProgress: false, mouse: { x: 0, y: 0 },
            currentWave: null, spawnTimer: 0, spawnIndex: 0,
            waveEndTimer: null, waveEndCountdown: 10,
            difficulty: null, gameSpeed: 1, speedIndex: 0
        };
        const DIFFICULTY_SETTINGS = {
            facil: { startingStaples: 250, startingHealth: 25, enemyHealthMultiplier: 0.8, towerCostMultiplier: 0.9 },
            normal: { startingStaples: 200, startingHealth: 20, enemyHealthMultiplier: 1.0, towerCostMultiplier: 1.0 },
            dificil: { startingStaples: 150, startingHealth: 15, enemyHealthMultiplier: 1.25, towerCostMultiplier: 1.1 },
        };
        const SPEED_MULTIPLIERS = [1, 2, 4];
        const TOWER_SPECS = {
            tack: { name: 'Tachinha', baseCost: 15, unlocksAtMap: 0, upgrades: [
                { cost: 20, damage: 8, range: 90, fireRate: 25, projectile: { speed: 6, size: 3, color: '#6b7280' } },
                { cost: 40, damage: 15, range: 100, fireRate: 20, projectile: { speed: 6, size: 4, color: '#4b5563' } },
                { cost: 75, damage: 25, range: 110, fireRate: 15, projectile: { speed: 7, size: 5, color: '#1f2937' } },
            ]},
            stapler: { name: 'Grampeador', baseCost: 40, unlocksAtMap: 0, upgrades: [
                { cost: 50, damage: 18, range: 100, fireRate: 50, burst: 3, projectile: { speed: 7, size: 4, color: '#a1a1aa'} },
                { cost: 100, damage: 30, range: 110, fireRate: 45, burst: 3, projectile: { speed: 7, size: 4, color: '#a1a1aa'} },
                { cost: 180, damage: 45, range: 120, fireRate: 40, burst: 4, projectile: { speed: 8, size: 5, color: '#a1a1aa'} },
            ]},
            highlighter: { name: 'Marca-Texto', baseCost: 60, unlocksAtMap: 0, upgrades: [
                { cost: 70, range: 120, fireRate: 150, slow: { factor: 0.5, duration: 120 }, projectile: { speed: 4, size: 8, color: '#ecfccb' } },
                { cost: 130, range: 130, fireRate: 140, slow: { factor: 0.4, duration: 150 }, projectile: { speed: 4, size: 9, color: '#d9f99d' } },
                { cost: 220, range: 140, fireRate: 130, slow: { factor: 0.3, duration: 180 }, projectile: { speed: 4, size: 10, color: '#bef264' } },
            ]},
            rubber_band: { name: 'El√°stico', baseCost: 75, unlocksAtMap: 2, upgrades: [
                { cost: 80, damage: 12, range: 110, fireRate: 90, splash: 30, projectile: { speed: 5, size: 5, color: '#f59e0b' } },
                { cost: 150, damage: 20, range: 120, fireRate: 85, splash: 35, projectile: { speed: 5, size: 6, color: '#f59e0b' } },
                { cost: 250, damage: 30, range: 130, fireRate: 80, splash: 40, projectile: { speed: 5, size: 7, color: '#f59e0b' } },
            ]},
            calculator: { name: 'Calculadora', baseCost: 120, unlocksAtMap: 5, upgrades: [
                { cost: 150, damage: 100, range: 250, fireRate: 200, projectile: { speed: 10, size: 6, color: '#ef4444' } },
                { cost: 250, damage: 220, range: 280, fireRate: 190, projectile: { speed: 10, size: 7, color: '#dc2626' } },
                { cost: 400, damage: 450, range: 320, fireRate: 180, projectile: { speed: 12, size: 8, color: '#b91c1c' } },
            ]},
        };
        const ENEMY_SPECS = {
            bug: { health: 50, speed: 1.5, size: 12, staples: 1 },
            glitch: { health: 30, speed: 2.5, size: 10, staples: 1 },
            crash: { health: 250, speed: 1, size: 18, staples: 5 },
            boss: { health: 2000, speed: 0.8, size: 25, staples: 25 },
        };
        const MAPS = [
            { name: 'Escrit√≥rio Aberto', path: [{x:0,y:4},{x:5,y:4},{x:5,y:11},{x:15,y:11},{x:15,y:2},{x:22,y:2}] },
            { name: 'Sala do Servidor', path: [{x:0,y:8},{x:3,y:8},{x:3,y:2},{x:9,y:2},{x:9,y:13},{x:3,y:13},{x:3,y:10},{x:17,y:10},{x:17,y:4},{x:22,y:4}] },
            { name: 'Copa', path: [{x:3,y:0},{x:3,y:5},{x:12,y:5},{x:12,y:2},{x:18,y:2},{x:18,y:8},{x:8,y:8},{x:8,y:13},{x:18,y:13},{x:18,y:16}] },
            { name: 'Corredor Longo', path: [{x:0,y:2},{x:18,y:2},{x:18,y:13},{x:2,y:13},{x:2,y:6},{x:22,y:6}]},
            { name: 'Mesa de Reuni√£o', path: [{x:0,y:8},{x:22,y:8}]},
            { name: 'Dep√≥sito', path: [{x:11,y:0},{x:11,y:5},{x:2,y:5},{x:2,y:11},{x:20,y:11},{x:20,y:2},{x:15,y:2},{x:15,y:16}]},
            { name: 'Recep√ß√£o', path: [{x:0,y:13},{x:5,y:13},{x:5,y:2},{x:17,y:2},{x:17,y:13},{x:22,y:13}]},
            { name: 'Labirinto de Baias', path: [{x:0,y:1},{x:2,y:1},{x:2,y:14},{x:5,y:14},{x:5,y:3},{x:8,y:3},{x:8,y:14},{x:11,y:14},{x:11,y:1},{x:22,y:1}]},
            { name: 'Sala do Chefe', path: [{x:2,y:0},{x:2,y:13},{x:20,y:13},{x:20,y:2},{x:8,y:2},{x:8,y:8},{x:22,y:8}]},
            { name: 'Terra√ßo', path: [{x:0,y:8},{x:5,y:8},{x:5,y:3},{x:16,y:3},{x:16,y:12},{x:5,y:12},{x:5,y:16}]}
        ];
        const WAVES = [];
        for (let i = 0; i < 50; i++) {
            let wave = { enemies: [] };
            let complexity = Math.floor(i / 5);
            let bugCount = 10 + i * 2;
            wave.enemies.push({type: 'bug', count: bugCount, delay: Math.max(15, 50 - i)});
            if (i > 2) {
                let glitchCount = 5 + Math.floor(i/2);
                wave.enemies.push({type: 'glitch', count: glitchCount, delay: Math.max(40, 100 - i)});
            }
            if (i > 4) {
                let crashCount = 3 + complexity;
                wave.enemies.push({type: 'crash', count: crashCount, delay: Math.max(100, 150 - i)});
            }
             if (i > 9 && (i + 1) % 5 === 0) {
                let bossCount = 1 + Math.floor((i-5)/5);
                wave.enemies.push({type: 'boss', count: bossCount, delay: 200});
            }
            WAVES.push(wave);
        }
        
        // --- UI & DOM REFERENCES ---
        const staplesEl = document.getElementById('staples-amount'), healthEl = document.getElementById('health-amount'), waveEl = document.getElementById('wave-number');
        const startWaveBtn = document.getElementById('start-wave-btn'), towerSelectionEl = document.getElementById('tower-selection');
        const upgradePanelEl = document.getElementById('upgrade-panel'), upgradeTowerNameEl = document.getElementById('upgrade-tower-name');
        const upgradeTowerLevelEl = document.getElementById('upgrade-tower-level'), upgradeTowerDamageEl = document.getElementById('upgrade-tower-damage');
        const upgradeTowerRangeEl = document.getElementById('upgrade-tower-range'), upgradeBtn = document.getElementById('upgrade-btn'), sellBtn = document.getElementById('sell-btn');
        const pauseBtn = document.getElementById('pause-btn'), speedBtn = document.getElementById('speed-btn'), muteBtn = document.getElementById('mute-btn');

        // --- SPATIAL GRID FOR PERFORMANCE ---
        const CELL_SIZE = 80;
        const GRID_COLS = Math.ceil(canvas.width / CELL_SIZE);
        const GRID_ROWS = Math.ceil(canvas.height / CELL_SIZE);
        const gridCells = Array.from({ length: GRID_COLS * GRID_ROWS }, () => []);
        function resetGrid() { for (let i = 0; i < gridCells.length; i++) gridCells[i].length = 0; }
        function getCellIndex(x, y) {
            const col = clamp(Math.floor(x / CELL_SIZE), 0, GRID_COLS - 1);
            const row = clamp(Math.floor(y / CELL_SIZE), 0, GRID_ROWS - 1);
            return row * GRID_COLS + col;
        }
        function addEnemyToGrid(enemy) { gridCells[getCellIndex(enemy.x, enemy.y)].push(enemy); }
        function forEachEnemyNear(x, y, radius, callback) {
            const minCol = clamp(Math.floor((x - radius) / CELL_SIZE), 0, GRID_COLS - 1);
            const maxCol = clamp(Math.floor((x + radius) / CELL_SIZE), 0, GRID_COLS - 1);
            const minRow = clamp(Math.floor((y - radius) / CELL_SIZE), 0, GRID_ROWS - 1);
            const maxRow = clamp(Math.floor((y + radius) / CELL_SIZE), 0, GRID_ROWS - 1);

            for (let r = minRow; r <= maxRow; r++) {
                for (let c = minCol; c <= maxCol; c++) {
                    const cell = gridCells[r * GRID_COLS + c];
                    for (const enemy of cell) {
                        callback(enemy);
                    }
                }
            }
        }
        
        // --- GAME CLASSES (Enemy, Tower, Projectile) ---
        class Enemy {
            constructor(type) {
                const pathStart = MAPS[gameState.mapIndex].path[0];
                this.x = pathStart.x * TILE_SIZE + TILE_SIZE / 2;
                this.y = pathStart.y * TILE_SIZE + TILE_SIZE / 2;
                this.pathIndex = 0;
                this.type = type;
                this.spec = ENEMY_SPECS[type];
                this.health = this.spec.health * (1 + (gameState.wave * 0.1)) * gameState.difficulty.enemyHealthMultiplier;
                this.maxHealth = this.health;
                this.speed = this.spec.speed;
                this.baseSpeed = this.spec.speed;
                this.size = this.spec.size;
                this.slowTimer = 0;
                this.glitchTimer = 0;
            }

            update() {
                if (this.slowTimer > 0) this.slowTimer--;
                else this.speed = this.baseSpeed;

                const path = MAPS[gameState.mapIndex].path;
                let distanceToTravel = this.speed;

                while (distanceToTravel > 0) {
                    if (this.pathIndex >= path.length - 1) {
                        gameState.health--;
                        playSound('error', 'A2');
                        return false;
                    }

                    const targetNode = path[this.pathIndex + 1];
                    const targetX = targetNode.x * TILE_SIZE + TILE_SIZE / 2;
                    const targetY = targetNode.y * TILE_SIZE + TILE_SIZE / 2;
                    
                    const dx = targetX - this.x;
                    const dy = targetY - this.y;
                    const distToNode = Math.hypot(dx, dy);

                    if (distToNode === 0) {
                        this.pathIndex++;
                        continue;
                    }
                    
                    const moveDistance = Math.min(distanceToTravel, distToNode);
                    this.x += (dx / distToNode) * moveDistance;
                    this.y += (dy / distToNode) * moveDistance;
                    distanceToTravel -= moveDistance;

                    if (moveDistance >= distToNode) {
                        this.pathIndex++;
                    }
                }
                return true;
            }

            draw() {
                const img = ASSETS.enemies[this.type];
                if (this.type === 'glitch') {
                    this.glitchTimer = (this.glitchTimer + 1) % 20;
                    if (this.glitchTimer < 10) return;
                }
                if (img && img.complete) {
                    const drawSize = this.size * 2.2;
                    ctx.drawImage(img, this.x - drawSize / 2, this.y - drawSize / 2, drawSize, drawSize);
                }

                const healthPercentage = this.health / this.maxHealth;
                ctx.fillStyle = '#dc2626';
                ctx.fillRect(this.x - this.size, this.y - this.size - 8, this.size * 2, 4);
                ctx.fillStyle = '#22c55e';
                ctx.fillRect(this.x - this.size, this.y - this.size - 8, this.size * 2 * healthPercentage, 4);
            }

            takeDamage(amount) {
                this.health -= amount;
                if (amount > 0) playSound('hit', 'G2', '32n');
                if (this.health <= 0) {
                    gameState.staples += this.spec.staples;
                    return false;
                }
                return true;
            }
        }

        class Tower {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type; this.level = 0;
                this.spec = TOWER_SPECS[type];
                this.target = null; this.fireCooldown = 0; this.burstCooldown = 0;
                this.burstCount = 0; this.rotation = 0;
            }

            getStats() { return this.spec.upgrades[this.level]; }

            update() {
                if (this.fireCooldown > 0) this.fireCooldown--;
                this.findTarget();
                if (this.target) {
                    const dx = this.target.x - this.x, dy = this.target.y - this.y;
                    this.rotation = Math.atan2(dy, dx);
                    if (this.fireCooldown <= 0) {
                        if (this.getStats().burst) {
                            this.burstCount = this.getStats().burst;
                            this.burstCooldown = 5;
                        } else this.shoot();
                        this.fireCooldown = this.getStats().fireRate;
                    }
                }

                if (this.burstCount > 0) {
                    if (this.burstCooldown > 0) this.burstCooldown--;
                    else {
                        this.shoot(); this.burstCount--; this.burstCooldown = 5;
                    }
                }
            }

            findTarget() {
                const range = this.getStats().range;
                const rangeSq = range * range;
                let closestDistSq = Infinity;
                let newTarget = null;
                
                forEachEnemyNear(this.x, this.y, range, (enemy) => {
                    const distSq = (enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2;
                    if (distSq < rangeSq && distSq < closestDistSq) {
                        closestDistSq = distSq;
                        newTarget = enemy;
                    }
                });
                this.target = newTarget;
            }

            shoot() {
                if (!this.target) return;
                const note = this.type === 'tack' ? 'G5' : this.type === 'stapler' ? 'C4' : this.type === 'rubber_band' ? 'A3' : 'B5';
                playSound('shoot', note);
                gameState.projectiles.push(new Projectile(this.x, this.y, this.target, this));
            }

            draw() {
                const img = ASSETS.towers[this.type][this.level];
                if (img && img.complete) {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.rotation + Math.PI / 2);
                    const drawSize = TILE_SIZE;
                    ctx.drawImage(img, -drawSize / 2, -drawSize / 2, drawSize, drawSize);
                    ctx.restore();
                }
            }

            drawRange() {
                ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
                ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.getStats().range, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }
        }

        class Projectile {
             constructor(x, y, target, tower) {
                this.x = x; this.y = y; this.target = target;
                this.tower = tower; this.stats = tower.getStats();
                this.rotation = tower.rotation;
            }

            update() {
                if (!this.target || this.target.health <= 0) return false;
                const dx = this.target.x - this.x, dy = this.target.y - this.y;
                const dist = Math.hypot(dx, dy);
                if (dist < this.stats.projectile.speed) {
                    this.hitTarget();
                    return false;
                }
                this.x += (dx / dist) * this.stats.projectile.speed;
                this.y += (dy / dist) * this.stats.projectile.speed;
                this.rotation = Math.atan2(dy, dx);
                return true;
            }

            hitTarget() {
                if (this.stats.splash) {
                    const radius = this.stats.splash;
                    const radiusSq = radius * radius;
                    const hitX = this.x, hitY = this.y;
                    forEachEnemyNear(hitX, hitY, radius, (enemy) => {
                        const distSq = (enemy.x - hitX) ** 2 + (enemy.y - hitY) ** 2;
                        if (distSq <= radiusSq) {
                            enemy.takeDamage(this.stats.damage);
                        }
                    });
                } else if (this.stats.slow) {
                    this.target.takeDamage(0);
                    this.target.speed = this.target.baseSpeed * this.stats.slow.factor;
                    this.target.slowTimer = this.stats.slow.duration;
                } else {
                    this.target.takeDamage(this.stats.damage);
                }
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.fillStyle = this.stats.projectile.color;
                if (this.tower.type === 'stapler') {
                     ctx.fillRect(-5, -1, 10, 2);
                } else {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.stats.projectile.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }
        }
        
        // --- CORE GAME LOGIC ---
        function init() {
            showModal('Carregando...', 'Preparando o material de escrit√≥rio...', '', ()=>{});
            defineAssets();
            preloadAssets(() => {
                setupEventListeners();
                showDifficultySelection();
                gameLoop();
            });
        }
        function gameLoop() {
            for (let i = 0; i < gameState.gameSpeed; i++) update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function update() {
            if (gameState.status !== 'PLAYING') return;

            // Spawn
            if (gameState.waveInProgress) {
                if (gameState.spawnTimer > 0) gameState.spawnTimer--;
                else {
                    const part = gameState.currentWave.enemies[gameState.spawnIndex];
                    if (part && part.spawned < part.count) {
                        gameState.enemies.push(new Enemy(part.type));
                        part.spawned++;
                        gameState.spawnTimer = part.delay;
                    } else if (part && part.spawned >= part.count) {
                        gameState.spawnIndex++;
                    }
                }
            }

            // Update & Filter
            resetGrid();
            gameState.enemies = gameState.enemies.filter(e => {
                const alive = e.update();
                if (alive) addEnemyToGrid(e);
                return alive;
            });
            gameState.towers.forEach(t => t.update());
            gameState.projectiles = gameState.projectiles.filter(p => p.update());
            
            updateUI();

            // Check game state
            if (gameState.waveInProgress && gameState.enemies.length === 0 && gameState.spawnIndex >= gameState.currentWave.enemies.length) {
                endWave();
            }
            if (gameState.health <= 0) {
                changeStatus('GAMEOVER');
                showModal('Fim de Jogo', 'Os bugs dominaram o escrit√≥rio!', 'Recome√ßar', showDifficultySelection);
            }
        }
        
        function draw() {
            ctx.drawImage(bgCanvas, 0, 0);
            drawMapPath();
            if (gameState.selectedTowerToPlace) drawPlacementPreview();
            gameState.towers.forEach(t => t.draw());
            if (gameState.selectedPlacedTower) {
                gameState.selectedPlacedTower.drawRange();
                ctx.strokeStyle = '#3b82f6'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.arc(gameState.selectedPlacedTower.x, gameState.selectedPlacedTower.y, TOWER_RADIUS, 0, Math.PI * 2); ctx.stroke();
            }
            gameState.enemies.forEach(e => e.draw());
            gameState.projectiles.forEach(p => p.draw());
            if (gameState.status === 'PAUSED') drawPauseOverlay();
        }

        function drawPauseOverlay() {
            ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white'; ctx.font = 'bold 48px Inter, sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText('JOGO PAUSADO', canvas.width / 2, canvas.height / 2);
        }

        function drawMapPath() {
            const path = MAPS[gameState.mapIndex].path;
            const px = p => p.x * TILE_SIZE + TILE_SIZE / 2;
            const py = p => p.y * TILE_SIZE + TILE_SIZE / 2;
            ctx.strokeStyle = 'rgba(0,0,0,0.05)'; ctx.lineWidth = TILE_SIZE; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            ctx.beginPath(); ctx.moveTo(px(path[0]), py(path[0]));
            for (let i = 1; i < path.length; i++) ctx.lineTo(px(path[i]), py(path[i]));
            ctx.stroke();
            
            const endPoint = path[path.length - 1];
            ctx.fillStyle = '#78350f'; ctx.fillRect(endPoint.x * TILE_SIZE - TILE_SIZE, endPoint.y * TILE_SIZE, TILE_SIZE, TILE_SIZE * 2);
            ctx.fillStyle = '#1e293b'; ctx.fillRect(endPoint.x * TILE_SIZE - TILE_SIZE + 5, endPoint.y * TILE_SIZE + 5, TILE_SIZE - 10, 10);
            ctx.fillStyle = '#f3f4f6'; ctx.beginPath(); ctx.arc(endPoint.x * TILE_SIZE - TILE_SIZE / 2, endPoint.y * TILE_SIZE + 25, 5, 0, Math.PI * 2); ctx.fill();
        }

        function drawPlacementPreview() {
            const gx = Math.floor(gameState.mouse.x / TILE_SIZE) * TILE_SIZE + TILE_SIZE / 2;
            const gy = Math.floor(gameState.mouse.y / TILE_SIZE) * TILE_SIZE + TILE_SIZE / 2;
            const can = canPlaceTower(gx, gy);
            ctx.fillStyle = can ? 'rgba(34,197,94,0.18)' : 'rgba(239,68,68,0.18)';
            ctx.strokeStyle = can ? 'rgba(34,197,94,0.60)' : 'rgba(239,68,68,0.60)';
            ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(gx, gy, TOWER_RADIUS + 2, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
            const spec = TOWER_SPECS[gameState.selectedTowerToPlace];
            ctx.beginPath(); ctx.arc(gx, gy, spec.upgrades[0].range, 0, Math.PI * 2); ctx.strokeStyle = 'rgba(59,130,246,0.25)'; ctx.stroke();
        }

        function startWave() {
            if (gameState.waveEndTimer) { clearInterval(gameState.waveEndTimer); gameState.waveEndTimer = null; }
            if (gameState.status !== 'PLAYING' || gameState.waveInProgress) return;
            gameState.wave++; gameState.waveInProgress = true;
            startWaveBtn.disabled = true; startWaveBtn.textContent = `ONDA ${gameState.wave} EM CURSO`; pauseBtn.disabled = false;
            const waveData = JSON.parse(JSON.stringify(WAVES[gameState.wave - 1]));
            waveData.enemies.forEach(part => part.spawned = 0);
            gameState.currentWave = waveData; gameState.spawnIndex = 0; gameState.spawnTimer = 0;
        }
        
        function endWave() {
            gameState.waveInProgress = false; startWaveBtn.disabled = false; pauseBtn.disabled = true;
            gameState.staples += 100 + gameState.wave * 10;

            if (gameState.wave >= WAVES.length) {
                changeStatus('VICTORY'); showModal('Vit√≥ria!', 'Voc√™ defendeu a m√°quina de caf√©!', 'Jogar Novamente', showDifficultySelection);
            } else if (gameState.wave % 5 === 0 && gameState.mapIndex < MAPS.length - 1) {
                let refund = 0; gameState.towers.forEach(t => { refund += getTowerValue(t); });
                gameState.staples += refund; gameState.towers = []; deselectAll();
                const oldMapIndex = gameState.mapIndex; gameState.mapIndex++;
                const newTowers = getNewUnlocks(oldMapIndex, gameState.mapIndex);
                let modalText = `Voc√™ avan√ßou para a ${MAPS[gameState.mapIndex].name}!\nTodas as suas defesas foram vendidas pelo valor total.`;
                if (newTowers.length > 0) modalText += `\n\nNovas defesas desbloqueadas:\n${newTowers.map(t => `${TOWER_SPECS[t].name}`).join('\n')}`;
                populateTowerShop(); renderBackground(); changeStatus('LEVEL_TRANSITION');
                showModal('Novo N√≠vel!', modalText, 'Continuar', () => { changeStatus('PLAYING'); startWaveEndTimer(); });
            } else { startWaveEndTimer(); }
        }
        
        function startWaveEndTimer() {
            gameState.waveEndCountdown = 10; startWaveBtn.textContent = `PR√ìXIMA ONDA EM ${gameState.waveEndCountdown}`;
            gameState.waveEndTimer = setInterval(updateWaveEndTimer, 1000);
        }
        function updateWaveEndTimer() {
            gameState.waveEndCountdown--; startWaveBtn.textContent = `PR√ìXIMA ONDA EM ${gameState.waveEndCountdown}`;
            if (gameState.waveEndCountdown <= 0) startWave();
        }
        
        function startGame(difficulty) {
            gameState.difficulty = DIFFICULTY_SETTINGS[difficulty];
            resetGame();
            if (!audio.ready) initAudio();
        }
        function resetGame() {
            if (gameState.waveEndTimer) { clearInterval(gameState.waveEndTimer); gameState.waveEndTimer = null; }
            gameState.staples = gameState.difficulty.startingStaples; gameState.health = gameState.difficulty.startingHealth;
            gameState.wave = 0; gameState.mapIndex = 0; gameState.enemies = []; gameState.towers = []; gameState.projectiles = [];
            gameState.waveInProgress = false; deselectAll();
            startWaveBtn.disabled = false; startWaveBtn.textContent = 'INICIAR ONDA'; pauseBtn.disabled = true;
            populateTowerShop(); renderBackground(); changeStatus('PLAYING');
        }

        // --- AUDIO ---
        function initAudio() {
            if (audio.ready) return;
            Tone.start();
            audio.synths.shoot = new Tone.Synth({ volume: -15, oscillator: { type: 'square' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 } }).toDestination();
            audio.synths.place = new Tone.Synth({ volume: -10, oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.2 } }).toDestination();
            audio.synths.upgrade = new Tone.PluckSynth({ volume: -5 }).toDestination();
            audio.synths.error = new Tone.Synth({ volume: -10, oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.1 } }).toDestination();
            audio.synths.hit = new Tone.MembraneSynth({ volume: -20, pitchDecay: 0.01, octaves: 2, envelope: { attack: 0.001, decay: 0.1, sustain: 0 } }).toDestination();
            audio.music = new Tone.Loop(time => {
                audio.synths.place.triggerAttackRelease("C2", "8n", time);
                audio.synths.place.triggerAttackRelease("G2", "8n", time + Tone.Time("8n"));
            }, "1n").start(0);
            Tone.Transport.start(); audio.ready = true;
        }
        function playSound(synthName, note, duration = '16n') {
            if (!audio.ready || audio.muted) return;
            if (synthName === 'hit') {
                const now = Tone.now();
                if (now < audio.lastHitSoundTime + audio.hitSoundInterval) return;
                audio.lastHitSoundTime = now;
            }
            if (audio.synths[synthName]) audio.synths[synthName].triggerAttackRelease(note, duration);
        }

        // --- UI & UTILS ---
        function getTowerCost(type, level = 0) {
            const spec = TOWER_SPECS[type];
            const base = (level === 0) ? spec.baseCost : spec.upgrades[level - 1].cost;
            return Math.floor(base * gameState.difficulty.towerCostMultiplier);
        }
        function getTowerValue(tower) {
            let total = getTowerCost(tower.type, 0);
            for (let i = 0; i < tower.level; i++) total += getTowerCost(tower.type, i + 1);
            return total;
        }
        function updateUI() {
            staplesEl.textContent = gameState.staples; healthEl.textContent = gameState.health; waveEl.textContent = gameState.wave;
            if (gameState.selectedPlacedTower) {
                const t = gameState.selectedPlacedTower, stats = t.getStats(), next = t.spec.upgrades[t.level + 1];
                upgradePanelEl.classList.remove('hidden');
                upgradeTowerNameEl.textContent = t.spec.name; upgradeTowerLevelEl.textContent = t.level + 1;
                upgradeTowerDamageEl.textContent = stats.damage || 'N/A'; upgradeTowerRangeEl.textContent = stats.range;
                if (next) {
                    const cost = getTowerCost(t.type, t.level + 1);
                    upgradeBtn.disabled = gameState.staples < cost; upgradeBtn.textContent = `Upgrade (üìé ${cost})`;
                } else { upgradeBtn.textContent = 'N√≠vel M√°ximo'; upgradeBtn.disabled = true; }
                sellBtn.textContent = `Vender (üìé ${Math.floor(getTowerValue(t) * 0.75)})`;
            } else upgradePanelEl.classList.add('hidden');
        }
        function populateTowerShop() {
            towerSelectionEl.innerHTML = '';
            for (const key in TOWER_SPECS) {
                const spec = TOWER_SPECS[key];
                if (gameState.mapIndex >= spec.unlocksAtMap) {
                    const card = document.createElement('div'); card.className = 'tower-card bg-gray-50 p-2 rounded-lg cursor-pointer flex items-center gap-4';
                    card.dataset.towerType = key;
                    const cost = gameState.difficulty ? getTowerCost(key) : spec.baseCost;
                    card.innerHTML = `<div class="tower-card-img" style="background-image: url('${ASSETS.towers[key][0].src}')"></div>
                        <div><h3 class="font-semibold text-gray-800">${spec.name}</h3><p class="font-bold text-gray-600">üìé ${cost}</p></div>`;
                    towerSelectionEl.appendChild(card);
                }
            }
        }
        function getNewUnlocks(oldIdx, newIdx) {
            const unlocks = []; for (const key in TOWER_SPECS) { const spec = TOWER_SPECS[key]; if (spec.unlocksAtMap > oldIdx && spec.unlocksAtMap <= newIdx) unlocks.push(key); } return unlocks;
        }
        function showModal(title, text, btnText, callback) {
            const modalTitle = document.getElementById('modal-title'), modalContent = document.getElementById('modal-content'), modalButtons = document.getElementById('modal-buttons');
            modalTitle.textContent = title; modalContent.textContent = text; modalButtons.innerHTML = '';
            if (btnText && callback) {
                const btn = document.createElement('button'); btn.className = 'bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-lg text-xl';
                btn.textContent = btnText; btn.onclick = callback; modalButtons.appendChild(btn);
            }
            document.getElementById('modal').classList.remove('modal-hidden');
        }
        function showDifficultySelection() {
            const modalTitle = document.getElementById('modal-title'), modalContent = document.getElementById('modal-content'), modalButtons = document.getElementById('modal-buttons');
            modalTitle.textContent = "Office Uprising"; modalContent.textContent = "Selecione o n√≠vel de dificuldade para come√ßar.";
            modalButtons.innerHTML = `<button id="easy-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-lg text-xl mx-2">F√°cil</button>
                <button id="normal-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-lg text-xl mx-2">Normal</button>
                <button id="hard-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-8 rounded-lg text-xl mx-2">Dif√≠cil</button>`;
            document.getElementById('easy-btn').onclick = () => startGame('facil');
            document.getElementById('normal-btn').onclick = () => startGame('normal');
            document.getElementById('hard-btn').onclick = () => startGame('dificil');
            document.getElementById('modal').classList.remove('modal-hidden');
        }
        function changeStatus(s) { gameState.status = s; if (!['LEVEL_TRANSITION', 'GAMEOVER', 'VICTORY', 'START'].includes(s)) document.getElementById('modal').classList.add('modal-hidden'); }
        function deselectAll() { gameState.selectedTowerToPlace = null; gameState.selectedPlacedTower = null; document.querySelectorAll('.tower-card.selected').forEach(c => c.classList.remove('selected')); updateUI(); }
        function setupEventListeners() {
            towerSelectionEl.addEventListener('click', e => {
                const card = e.target.closest('.tower-card'); if (!card) return;
                const type = card.dataset.towerType, cost = getTowerCost(type);
                if (gameState.staples >= cost) { deselectAll(); gameState.selectedTowerToPlace = type; card.classList.add('selected'); }
            });
            canvas.addEventListener('mousemove', e => { const r = canvas.getBoundingClientRect(); gameState.mouse.x = e.clientX - r.left; gameState.mouse.y = e.clientY - r.top; });
            canvas.addEventListener('click', () => {
                if (gameState.status !== 'PLAYING') return;
                const gx = Math.floor(gameState.mouse.x / TILE_SIZE) * TILE_SIZE + TILE_SIZE / 2;
                const gy = Math.floor(gameState.mouse.y / TILE_SIZE) * TILE_SIZE + TILE_SIZE / 2;
                if (gameState.selectedTowerToPlace) {
                    const cost = getTowerCost(gameState.selectedTowerToPlace);
                    if (gameState.staples >= cost && canPlaceTower(gx, gy)) {
                        gameState.towers.push(new Tower(gx, gy, gameState.selectedTowerToPlace));
                        gameState.staples -= cost; playSound('place', 'C5'); deselectAll();
                    } else if (!canPlaceTower(gx, gy)) { playSound('error', 'C3', '16n'); }
                } else {
                    let clicked = null; for (const t of gameState.towers) { if (Math.hypot(t.x - gx, t.y - gy) < TOWER_RADIUS) { clicked = t; break; } }
                    gameState.selectedPlacedTower = clicked; updateUI();
                }
            });
            upgradeBtn.addEventListener('click', () => {
                const t = gameState.selectedPlacedTower; if (!t) return; const next = t.spec.upgrades[t.level + 1]; if (!next) return;
                const cost = getTowerCost(t.type, t.level + 1);
                if (gameState.staples >= cost) { gameState.staples -= cost; t.level++; playSound('upgrade', 'E6'); updateUI(); }
            });
            sellBtn.addEventListener('click', () => {
                const t = gameState.selectedPlacedTower; if (!t) return;
                gameState.staples += Math.floor(getTowerValue(t) * 0.75);
                gameState.towers = gameState.towers.filter(x => x !== t);
                playSound('place', 'A4'); deselectAll();
            });
            startWaveBtn.addEventListener('click', startWave);
            pauseBtn.addEventListener('click', () => {
                if (gameState.status === 'PLAYING') { changeStatus('PAUSED'); pauseBtn.innerHTML = '‚ñ∂Ô∏è'; }
                else if (gameState.status === 'PAUSED') { changeStatus('PLAYING'); pauseBtn.innerHTML = '‚è∏Ô∏è'; }
                playSound('place', 'E5', '32n');
            });
            speedBtn.addEventListener('click', () => {
                gameState.speedIndex = (gameState.speedIndex + 1) % SPEED_MULTIPLIERS.length;
                gameState.gameSpeed = SPEED_MULTIPLIERS[gameState.speedIndex];
                speedBtn.textContent = `${gameState.gameSpeed}x`; playSound('place', 'G5', '32n');
            });
            muteBtn.addEventListener('click', () => {
                audio.muted = !audio.muted; muteBtn.textContent = audio.muted ? 'üîá' : 'üîä';
                if (audio.muted) Tone.Transport.pause(); else Tone.Transport.start();
            });
        }
        function renderBackground(){
            bgCtx.fillStyle = '#e5e7eb';
            bgCtx.fillRect(0,0,bgCanvas.width,bgCanvas.height);
        }

        // --- INIT ---
        init();
    </script>
</body>
</html>


