<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Office Uprising</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #f3f4f6; /* cinza claro de fundo */
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        canvas {
            cursor: pointer;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .ui-panel {
            background-color: #fff;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        .tower-card.selected, .tower-card:hover {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }
        .tower-card {
            transition: all 0.2s ease-in-out;
            border: 2px solid transparent;
        }
        .modal {
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .modal-hidden {
            opacity: 0;
            transform: scale(0.95);
            pointer-events: none;
        }
        /* Desabilitar setas do input number */
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
          -webkit-appearance: none; 
          margin: 0; 
        }
        input[type=number] {
          -moz-appearance: textfield;
        }
        .tower-card-img {
            width: 48px;
            height: 48px;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
        }
    </style>
</head>
<body class="flex flex-col xl:flex-row items-center justify-center min-h-screen p-4 gap-4">

    <!-- Painel de UI -->
    <div class="ui-panel w-full xl:w-96 p-5 flex-shrink-0 order-2 xl:order-1 self-stretch flex flex-col">
        <h1 class="text-3xl font-bold text-gray-800 text-center mb-4">OFFICE UPRISING</h1>
        
        <!-- Status do Jogo -->
        <div class="grid grid-cols-3 gap-3 text-center mb-4">
            <div class="bg-gray-100 p-2 rounded-lg">
                <div class="text-sm font-semibold text-gray-500">üìé Clipes</div>
                <div id="staples-amount" class="text-xl font-bold text-gray-800">200</div>
            </div>
            <div class="bg-gray-100 p-2 rounded-lg">
                <div class="text-sm font-semibold text-red-500">‚òïÔ∏è Pausas</div>
                <div id="health-amount" class="text-xl font-bold text-red-600">20</div>
            </div>
             <div class="bg-gray-100 p-2 rounded-lg">
                <div class="text-sm font-semibold text-blue-500">üåä Onda</div>
                <div id="wave-number" class="text-xl font-bold text-blue-600">0</div>
            </div>
        </div>
        
        <!-- Torres para Comprar -->
        <div id="tower-shop">
            <h2 class="text-lg font-semibold text-gray-700 mb-2">Defesas</h2>
            <div id="tower-selection" class="space-y-2">
                <!-- As torres ser√£o injetadas aqui pelo JS -->
            </div>
        </div>

        <!-- Painel de Upgrade (din√¢mico) -->
        <div id="upgrade-panel" class="hidden mt-4 pt-4 border-t">
            <h2 id="upgrade-tower-name" class="text-lg font-semibold text-gray-700 mb-2"></h2>
            <p class="text-sm text-gray-500 mb-2">N√≠vel: <span id="upgrade-tower-level"></span></p>
            <p class="text-sm text-gray-500 mb-3">Dano: <span id="upgrade-tower-damage"></span> | Alcance: <span id="upgrade-tower-range"></span></p>
            <button id="upgrade-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition"></button>
            <button id="sell-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition mt-2"></button>
        </div>

        <div class="flex-grow"></div>
        <div class="flex gap-2 mt-4">
            <button id="start-wave-btn" class="w-full bg-green-500 hover:bg-green-600 text-white text-xl font-bold py-3 rounded-lg shadow-md transition-transform transform hover:scale-105">INICIAR ONDA</button>
            <button id="pause-btn" class="flex-shrink-0 w-16 bg-gray-500 hover:bg-gray-600 text-white text-2xl font-bold py-3 rounded-lg shadow-md transition-transform transform hover:scale-105" disabled>‚è∏Ô∏è</button>
        </div>
    </div>

    <!-- √Årea do Jogo -->
    <div class="relative order-1 xl:order-2">
        <canvas id="gameCanvas" width="880" height="640"></canvas>
        <div id="modal" class="modal modal-hidden absolute inset-0 bg-black bg-opacity-75 flex flex-col items-center justify-center text-white text-center p-8 rounded-lg">
            <h2 id="modal-title" class="text-5xl font-bold mb-4"></h2>
            <p id="modal-text" class="text-lg mb-6 whitespace-pre-wrap"></p>
            <button id="modal-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-lg text-xl"></button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // --- ASSETS ---
        const ASSETS = {
            towers: {},
            enemies: {},
            maps: [],
        };

        function createSvgImage(svgString) {
            const img = new Image();
            img.src = 'data:image/svg+xml;base64,' + btoa(svgString);
            return img;
        }

        function defineAssets() {
            // Torres
            ASSETS.towers.tack = [
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,20)"><circle cx="0" cy="0" r="16" fill="#d1d5db"/><path d="M0 -14 L-4 4 L4 4 Z" fill="#ef4444"/><circle cx="0" cy="-15" r="5" fill="#f87171"/></g></svg>`),
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,20)"><circle cx="0" cy="0" r="17" fill="#9ca3af"/><g transform="rotate(0)"><path d="M0 -15 L-4 4 L4 4 Z" fill="#ef4444"/><circle cx="0" cy="-16" r="5" fill="#f87171"/></g><g transform="rotate(120)"><path d="M0 -15 L-4 4 L4 4 Z" fill="#ef4444"/><circle cx="0" cy="-16" r="5" fill="#f87171"/></g><g transform="rotate(240)"><path d="M0 -15 L-4 4 L4 4 Z" fill="#ef4444"/><circle cx="0" cy="-16" r="5" fill="#f87171"/></g></g></svg>`),
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,20)"><circle cx="0" cy="0" r="18" fill="#4b5563"/><g transform="rotate(0)"><path d="M0 -16 L-5 5 L5 5 Z" fill="#dc2626"/><circle cx="0" cy="-17" r="6" fill="#ef4444"/></g><g transform="rotate(72)"><path d="M0 -16 L-5 5 L5 5 Z" fill="#dc2626"/><circle cx="0" cy="-17" r="6" fill="#ef4444"/></g><g transform="rotate(144)"><path d="M0 -16 L-5 5 L5 5 Z" fill="#dc2626"/><circle cx="0" cy="-17" r="6" fill="#ef4444"/></g><g transform="rotate(216)"><path d="M0 -16 L-5 5 L5 5 Z" fill="#dc2626"/><circle cx="0" cy="-17" r="6" fill="#ef4444"/></g><g transform="rotate(288)"><path d="M0 -16 L-5 5 L5 5 Z" fill="#dc2626"/><circle cx="0" cy="-17" r="6" fill="#ef4444"/></g></g></svg>`),
            ];
            ASSETS.towers.stapler = [
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,18)"><path d="M-15 5 L15 5 L15 10 L-15 10 Z" fill="#6b7280"/><path d="M-15 -5 L12 -5 L15 5 L-15 5 Z" fill="#9ca3af"/><rect x="-13" y="-3" width="18" height="6" fill="#d1d5db"/></g></svg>`),
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,18)"><path d="M-17 6 L17 6 L17 12 L-17 12 Z" fill="#374151"/><path d="M-17 -6 L14 -6 L17 6 L-17 6 Z" fill="#6b7280"/><rect x="-15" y="-4" width="22" height="8" fill="#9ca3af"/><circle cx="12" cy="-2" r="2" fill="#ef4444"/></g></svg>`),
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,18)"><path d="M-18 7 L18 7 L18 14 L-18 14 Z" fill="#111827"/><path d="M-18 -7 L15 -7 L18 7 L-18 7 Z" fill="#4b5563"/><rect x="-16" y="-5" width="25" height="10" fill="#6b7280"/><path d="M10 -5 L15 -5 L15 5 L10 5Z" fill="#ef4444"/><rect x="-16" y="-1" width="3" height="3" fill="#facc15"/></g></svg>`),
            ];
            ASSETS.towers.highlighter = [
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,20) rotate(45)"><rect x="-5" y="-18" width="10" height="25" rx="3" fill="#f0fdf4"/><rect x="-5" y="7" width="10" height="8" rx="3" fill="#d1d5db"/><path d="M-5 -18 L5 -18 L0 -24 Z" fill="#fef08a"/></g></svg>`),
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,20) rotate(45)"><rect x="-6" y="-18" width="12" height="26" rx="4" fill="#dcfce7"/><rect x="-6" y="8" width="12" height="9" rx="4" fill="#9ca3af"/><path d="M-6 -18 L6 -18 L0 -25 Z" fill="#fde047"/><circle cx="0" cy="0" r="3" fill="#a3e635"/></g></svg>`),
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,20) rotate(45)"><rect x="-7" y="-20" width="14" height="28" rx="5" fill="#bbf7d0"/><rect x="-7" y="8" width="14" height="10" rx="5" fill="#6b7280"/><path d="M-7 -20 L7 -20 L0 -28 Z" fill="#facc15"/><path d="M-2 -5 L2 -5 L2 5 L-2 5Z" fill="#a3e635"/><path d="M-5 -2 L5 -2 L5 2 L-5 2Z" fill="#a3e635"/></g></svg>`),
            ];
            ASSETS.towers.rubber_band = [
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,20)"><circle cx="0" cy="0" r="12" fill="#f59e0b"/><circle cx="0" cy="0" r="10" stroke="#fcd34d" stroke-width="2" fill="none" transform="rotate(45)"/><circle cx="0" cy="0" r="8" stroke="#fbbf24" stroke-width="2" fill="none"/></g></svg>`),
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,20)"><circle cx="0" cy="0" r="15" fill="#f59e0b"/><circle cx="0" cy="0" r="13" stroke="#fcd34d" stroke-width="2.5" fill="none" transform="rotate(45)"/><circle cx="0" cy="0" r="10" stroke="#fbbf24" stroke-width="2.5" fill="none"/><circle cx="0" cy="0" r="7" stroke="#fde047" stroke-width="2.5" fill="none" transform="rotate(-30)"/></g></svg>`),
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,20)"><circle cx="0" cy="0" r="18" fill="#d97706"/><circle cx="0" cy="0" r="16" stroke="#fcd34d" stroke-width="3" fill="none" transform="rotate(45)"/><circle cx="0" cy="0" r="13" stroke="#fbbf24" stroke-width="3" fill="none"/><circle cx="0" cy="0" r="10" stroke="#fde047" stroke-width="3" fill="none" transform="rotate(-30)"/><circle cx="0" cy="0" r="7" stroke="#fef08a" stroke-width="3" fill="none" transform="rotate(15)"/></g></svg>`),
            ];
            ASSETS.towers.calculator = [
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,20) rotate(45)"><rect x="-10" y="-16" width="20" height="32" rx="3" fill="#4b5563"/><rect x="-8" y="-14" width="16" height="10" fill="#dcfce7"/><circle cx="0" cy="10" r="8" fill="#ef4444"/><circle cx="0" cy="10" r="3" fill="#fee2e2"/></g></svg>`),
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,20) rotate(45)"><rect x="-11" y="-17" width="22" height="34" rx="4" fill="#1f2937"/><rect x="-9" y="-15" width="18" height="12" fill="#bbf7d0"/><rect x="-9" y="-2" width="18" height="4" fill="#374151"/><circle cx="0" cy="12" r="9" fill="#dc2626"/><circle cx="0" cy="12" r="4" fill="#fecaca"/></g></svg>`),
                createSvgImage(`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><g transform="translate(20,20) rotate(45)"><rect x="-12" y="-18" width="24" height="36" rx="5" fill="#111827"/><rect x="-10" y="-16" width="20" height="14" fill="#a7f3d0"/><rect x="-10" y="-1" width="20" height="5" fill="#1f2937"/><path d="M-10 6 L10 6 L10 18 L-10 18Z" fill="#374151" /><circle cx="0" cy="13" r="10" fill="#b91c1c"/><circle cx="0" cy="13" r="5" fill="#fca5a5"/></g></svg>`),
            ];

            // Inimigos
            ASSETS.enemies.bug = createSvgImage(`<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="9" fill="#22c55e"/><circle cx="10" cy="10" r="2" fill="white"/><circle cx="14" cy="10" r="2" fill="white"/><circle cx="10" cy="10" r="1" fill="black"/><circle cx="14" cy="10" r="1" fill="black"/><path d="M8 15 Q12 17 16 15" stroke="black" stroke-width="1.5" fill="none"/></svg>`);
            ASSETS.enemies.glitch = createSvgImage(`<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M4 4 L20 4 L20 20 L4 20 Z" fill="#8b5cf6"/><rect x="6" y="9" width="4" height="6" fill="white"/><rect x="14" y="9" width="4" height="6" fill="white"/><rect x="7" y="10" width="2" height="4" fill="black"/><rect x="15" y="10" width="2" height="4" fill="black"/></svg>`);
            ASSETS.enemies.crash = createSvgImage(`<svg viewBox="0 0 36 36" xmlns="http://www.w3.org/2000/svg"><circle cx="18" cy="18" r="14" fill="#f97316"/><path d="M10 12 L26 28 M10 28 L26 12" stroke="#9a3412" stroke-width="4"/><circle cx="15" cy="15" r="3" fill="white"/><circle cx="21" cy="15" r="3" fill="white"/><circle cx="15" cy="15" r="1.5" fill="black"/><circle cx="21" cy="15" r="1.5" fill="black"/></svg>`);
            ASSETS.enemies.boss = createSvgImage(`<svg viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg"><path d="M25 2 C12 2 2 12 2 25 C2 38 12 48 25 48 S48 38 48 25 C48 12 38 2 25 2Z" fill="#be123c"/><path d="M15 15 L22 25 L15 35 M35 15 L28 25 L35 35" stroke="white" stroke-width="4" fill="none"/><circle cx="25" cy="25" r="5" fill="#fca5a5"/><circle cx="25" cy="25" r="2" fill="#991b1b"/></svg>`);

            // Mapas (s√£o carregados dinamicamente, mas listados aqui para o preloader)
            MAPS.forEach(map => ASSETS.maps.push(new Image()));
        }

        function preloadAssets(callback) {
            const assetsToLoad = [];
            
            // Adicionar todas as imagens dos mapas
            MAPS.forEach((map, index) => {
                const img = ASSETS.maps[index];
                img.src = map.backgroundImage;
                assetsToLoad.push(img);
            });

            // Adicionar todas as imagens de torres e inimigos
            for (const type in ASSETS.towers) {
                ASSETS.towers[type].forEach(img => assetsToLoad.push(img));
            }
            for (const type in ASSETS.enemies) {
                assetsToLoad.push(ASSETS.enemies[type]);
            }

            if (assetsToLoad.length === 0) {
                callback();
                return;
            }

            let loadedCount = 0;
            assetsToLoad.forEach(asset => {
                asset.onload = () => {
                    loadedCount++;
                    if (loadedCount === assetsToLoad.length) {
                        callback();
                    }
                };
                asset.onerror = () => { // Adicionado para depura√ß√£o
                    console.error("Falha ao carregar asset:", asset.src);
                    loadedCount++;
                    if (loadedCount === assetsToLoad.length) {
                        callback();
                    }
                }
            });
        }

        // --- CONFIGURA√á√ïES & ESTADO DO JOGO ---
        const TILE_SIZE = 40;
        let gameState = {
            staples: 200,
            health: 20,
            wave: 0,
            mapIndex: 0,
            status: 'START', // START, PLAYING, PAUSED, WAVEOVER, GAMEOVER, VICTORY, LEVEL_TRANSITION
            enemies: [],
            towers: [],
            projectiles: [],
            particles: [],
            selectedTowerToPlace: null,
            selectedPlacedTower: null,
            waveInProgress: false,
            mouse: { x: 0, y: 0, down: false },
            currentWave: null,
            spawnTimer: 0,
            spawnIndex: 0,
            waveEndTimer: null,
            waveEndCountdown: 10,
        };
        
        // --- ELEMENTOS DA UI ---
        const staplesEl = document.getElementById('staples-amount');
        const healthEl = document.getElementById('health-amount');
        const waveEl = document.getElementById('wave-number');
        const startWaveBtn = document.getElementById('start-wave-btn');
        const towerSelectionEl = document.getElementById('tower-selection');
        const upgradePanelEl = document.getElementById('upgrade-panel');
        const upgradeTowerNameEl = document.getElementById('upgrade-tower-name');
        const upgradeTowerLevelEl = document.getElementById('upgrade-tower-level');
        const upgradeTowerDamageEl = document.getElementById('upgrade-tower-damage');
        const upgradeTowerRangeEl = document.getElementById('upgrade-tower-range');
        const upgradeBtn = document.getElementById('upgrade-btn');
        const sellBtn = document.getElementById('sell-btn');
        const pauseBtn = document.getElementById('pause-btn');

        // --- DEFINI√á√ïES DE TORRES, INIMIGOS, MAPAS E ONDAS ---
        const TOWER_SPECS = {
            tack: { name: 'Tachinha', icon: 'üìç', baseCost: 15, unlocksAtMap: 0, upgrades: [
                { cost: 20, damage: 8, range: 90, fireRate: 25, projectile: { speed: 6, size: 3, color: '#6b7280' } },
                { cost: 40, damage: 15, range: 100, fireRate: 20, projectile: { speed: 6, size: 4, color: '#4b5563' } },
                { cost: 75, damage: 25, range: 110, fireRate: 15, projectile: { speed: 7, size: 5, color: '#1f2937' } },
            ]},
            stapler: { name: 'Grampeador', icon: 'üìé', baseCost: 40, unlocksAtMap: 0, upgrades: [
                { cost: 50, damage: 18, range: 100, fireRate: 50, burst: 3, projectile: { speed: 7, size: 4, color: '#a1a1aa'} },
                { cost: 100, damage: 30, range: 110, fireRate: 45, burst: 3, projectile: { speed: 7, size: 4, color: '#a1a1aa'} },
                { cost: 180, damage: 45, range: 120, fireRate: 40, burst: 4, projectile: { speed: 8, size: 5, color: '#a1a1aa'} },
            ]},
            highlighter: { name: 'Marca-Texto', icon: 'üñçÔ∏è', baseCost: 60, unlocksAtMap: 0, upgrades: [
                { cost: 70, range: 120, fireRate: 150, slow: { factor: 0.5, duration: 120 }, projectile: { speed: 4, size: 8, color: '#ecfccb' } },
                { cost: 130, range: 130, fireRate: 140, slow: { factor: 0.4, duration: 150 }, projectile: { speed: 4, size: 9, color: '#d9f99d' } },
                { cost: 220, range: 140, fireRate: 130, slow: { factor: 0.3, duration: 180 }, projectile: { speed: 4, size: 10, color: '#bef264' } },
            ]},
            rubber_band: { name: 'El√°stico', icon: '„Ç¥„É†', baseCost: 75, unlocksAtMap: 1, upgrades: [ // Icon adjusted for visibility
                { cost: 80, damage: 12, range: 110, fireRate: 90, splash: 30, projectile: { speed: 5, size: 5, color: '#f59e0b' } },
                { cost: 150, damage: 20, range: 120, fireRate: 85, splash: 35, projectile: { speed: 5, size: 6, color: '#f59e0b' } },
                { cost: 250, damage: 30, range: 130, fireRate: 80, splash: 40, projectile: { speed: 5, size: 7, color: '#f59e0b' } },
            ]},
            calculator: { name: 'Calculadora', icon: 'üßÆ', baseCost: 120, unlocksAtMap: 2, upgrades: [
                { cost: 150, damage: 100, range: 250, fireRate: 200, projectile: { speed: 10, size: 6, color: '#ef4444' } },
                { cost: 250, damage: 220, range: 280, fireRate: 190, projectile: { speed: 10, size: 7, color: '#dc2626' } },
                { cost: 400, damage: 450, range: 320, fireRate: 180, projectile: { speed: 12, size: 8, color: '#b91c1c' } },
            ]},
        };

        const ENEMY_SPECS = {
            bug: { health: 50, speed: 1.5, size: 12, staples: 1 },
            glitch: { health: 30, speed: 2.5, size: 10, staples: 1 },
            crash: { health: 250, speed: 1, size: 18, staples: 5 },
            boss: { health: 2000, speed: 0.8, size: 25, staples: 25 },
        };
        
        const MAPS = [
            { name: 'Escrit√≥rio Aberto', backgroundImage: 'https://storage.googleapis.com/gemini-prod-us-west1-assets/e65e68b32585287c_i4_2_map1.jpg', path: [{x:0,y:4},{x:5,y:4},{x:5,y:11},{x:15,y:11},{x:15,y:2},{x:22,y:2}] },
            { name: 'Sala do Servidor', backgroundImage: 'https://storage.googleapis.com/gemini-prod-us-west1-assets/56f738cb34771f2a_i4_2_map2.jpg', path: [{x:0,y:8},{x:3,y:8},{x:3,y:2},{x:9,y:2},{x:9,y:13},{x:3,y:13},{x:3,y:10},{x:17,y:10},{x:17,y:4},{x:22,y:4}] },
            { name: 'Copa', backgroundImage: 'https://storage.googleapis.com/gemini-prod-us-west1-assets/e162788e02237063_i4_2_map3.jpg', path: [{x:3,y:0},{x:3,y:5},{x:12,y:5},{x:12,y:2},{x:18,y:2},{x:18,y:8},{x:8,y:8},{x:8,y:13},{x:18,y:13},{x:18,y:16}] }
        ];

        const WAVES = [
            // Map 1: Waves 1-5
            { enemies: [{ type: 'bug', count: 10, delay: 50 }] },
            { enemies: [{ type: 'bug', count: 15, delay: 45 }] },
            { enemies: [{ type: 'bug', count: 10, delay: 40 }, { type: 'glitch', count: 5, delay: 100 }] },
            { enemies: [{ type: 'glitch', count: 15, delay: 50 }] },
            { enemies: [{ type: 'crash', count: 3, delay: 150 }] },
            // Map 2: Waves 6-10
            { enemies: [{ type: 'bug', count: 20, delay: 30 }, { type: 'glitch', count: 10, delay: 80 }] },
            { enemies: [{ type: 'crash', count: 5, delay: 120 }, { type: 'glitch', count: 10, delay: 100 }] },
            { enemies: [{ type: 'bug', count: 50, delay: 20 }] },
            { enemies: [{ type: 'crash', count: 10, delay: 100 }] },
            { enemies: [{ type: 'boss', count: 1, delay: 100 }] },
            // Map 3: Waves 11-15
            { enemies: [{ type: 'bug', count: 30, delay: 25 }, { type: 'crash', count: 5, delay: 150 }] },
            { enemies: [{ type: 'glitch', count: 40, delay: 30 }] },
            { enemies: [{ type: 'crash', count: 15, delay: 80 }] },
            { enemies: [{ type: 'boss', count: 1, delay: 100 }, { type: 'glitch', count: 20, delay: 90 }] },
            { enemies: [{ type: 'boss', count: 2, delay: 250 }, { type: 'bug', count: 20, delay: 50 }] },
        ];
        
        // --- CLASSES DE JOGO ---
        class Enemy {
            constructor(type) {
                const pathStart = MAPS[gameState.mapIndex].path[0];
                this.x = pathStart.x * TILE_SIZE;
                this.y = pathStart.y * TILE_SIZE + TILE_SIZE / 2;
                this.pathIndex = 0;
                this.type = type;
                this.spec = ENEMY_SPECS[type];
                this.health = this.spec.health * (1 + (gameState.wave * 0.1)); // Escala com a onda
                this.maxHealth = this.health;
                this.speed = this.spec.speed;
                this.baseSpeed = this.spec.speed;
                this.size = this.spec.size;
                this.slowTimer = 0;
                this.glitchTimer = 0;
            }

            update() {
                if (this.slowTimer > 0) this.slowTimer--;
                else this.speed = this.baseSpeed;

                const path = MAPS[gameState.mapIndex].path;
                if (this.pathIndex >= path.length - 1) {
                    gameState.health--;
                    return false;
                }

                const target = path[this.pathIndex + 1];
                const targetX = target.x * TILE_SIZE + TILE_SIZE / 2;
                const targetY = target.y * TILE_SIZE + TILE_SIZE / 2;
                
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < this.speed) this.pathIndex++;
                else {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                }
                return true;
            }

            draw() {
                const img = ASSETS.enemies[this.type];
                if (this.type === 'glitch') {
                    this.glitchTimer = (this.glitchTimer + 1) % 20;
                    if (this.glitchTimer < 10) return; // Flickering effect
                }
                if (img && img.complete) {
                    ctx.drawImage(img, this.x - img.width / 2, this.y - img.height / 2);
                }

                const healthPercentage = this.health / this.maxHealth;
                ctx.fillStyle = '#dc2626';
                ctx.fillRect(this.x - this.size, this.y - this.size - 8, this.size * 2, 4);
                ctx.fillStyle = '#22c55e';
                ctx.fillRect(this.x - this.size, this.y - this.size - 8, this.size * 2 * healthPercentage, 4);
            }

            takeDamage(amount) {
                this.health -= amount;
                if (this.health <= 0) {
                    gameState.staples += this.spec.staples;
                    return false;
                }
                return true;
            }
        }

        class Tower {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.level = 0;
                this.spec = TOWER_SPECS[type];
                this.target = null;
                this.fireCooldown = 0;
                this.burstCooldown = 0;
                this.burstCount = 0;
                this.rotation = 0;
            }

            getStats() { return this.spec.upgrades[this.level]; }

            update() {
                if (this.fireCooldown > 0) this.fireCooldown--;

                this.findTarget();
                if (this.target) {
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    this.rotation = Math.atan2(dy, dx);

                    if (this.fireCooldown <= 0) {
                        if (this.getStats().burst) {
                            this.burstCount = this.getStats().burst;
                            this.burstCooldown = 5;
                        } else this.shoot();
                        this.fireCooldown = this.getStats().fireRate;
                    }
                }

                if(this.burstCount > 0) {
                    if(this.burstCooldown > 0) this.burstCooldown--;
                    else {
                        this.shoot();
                        this.burstCount--;
                        this.burstCooldown = 5;
                    }
                }
            }

            findTarget() {
                if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.getStats().range) return;
                this.target = null;
                let closestDist = Infinity;
                for (const enemy of gameState.enemies) {
                    const dist = getDistance(this, enemy);
                    if (dist <= this.getStats().range && dist < closestDist) {
                        closestDist = dist;
                        this.target = enemy;
                    }
                }
            }

            shoot() {
                if (!this.target) return;
                gameState.projectiles.push(new Projectile(this.x, this.y, this.target, this));
            }

            draw() {
                const img = ASSETS.towers[this.type][this.level];
                if (img && img.complete) {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.rotation + Math.PI / 2); // Adjust rotation to match asset orientation
                    ctx.drawImage(img, -img.width / 2, -img.height / 2);
                    ctx.restore();
                }
            }

            drawRange() {
                ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
                ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.getStats().range, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }
        }

        class Projectile {
             constructor(x, y, target, tower) {
                this.x = x;
                this.y = y;
                this.target = target;
                this.tower = tower;
                this.stats = tower.getStats();
                this.rotation = tower.rotation;
            }

            update() {
                if (!this.target || this.target.health <= 0) return false;

                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < this.stats.projectile.speed) {
                    this.hitTarget();
                    return false;
                } else {
                    this.x += (dx / dist) * this.stats.projectile.speed;
                    this.y += (dy / dist) * this.stats.projectile.speed;
                    this.rotation = Math.atan2(dy, dx);
                }
                return true;
            }

            hitTarget() {
                if (this.stats.splash) { // Splash damage
                    gameState.enemies.forEach(enemy => {
                        if (getDistance(this.target, enemy) <= this.stats.splash) {
                            enemy.takeDamage(this.stats.damage);
                        }
                    });
                } else if (this.stats.slow) { // Slow effect
                    this.target.takeDamage(0); // No damage for highlighter
                    this.target.speed = this.target.baseSpeed * this.stats.slow.factor;
                    this.target.slowTimer = this.stats.slow.duration;
                } else { // Single target damage
                    this.target.takeDamage(this.stats.damage);
                }
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.fillStyle = this.stats.projectile.color;
                if (this.tower.type === 'stapler') { // Draw staple shape
                     ctx.fillRect(-5, -1, 10, 2);
                } else { // Default circle
                    ctx.beginPath();
                    ctx.arc(0, 0, this.stats.projectile.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }
        }
        
        // --- FUN√á√ïES PRINCIPAIS DO JOGO ---
        function init() {
            showModal('Carregando...', 'Preparando o material de escrit√≥rio...', '', ()=>{});
            defineAssets();
            preloadAssets(() => {
                populateTowerShop();
                setupEventListeners();
                showModal('Office Uprising', `Os "Bugs" est√£o atacando! Proteja a M√°quina de Caf√© a todo custo.`, 'Come√ßar', () => changeStatus('PLAYING'));
                gameLoop();
            });
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function update() {
            if (gameState.status !== 'PLAYING') return;

            if(gameState.waveInProgress) {
                if(gameState.spawnTimer > 0) gameState.spawnTimer--;
                else {
                    const wavePart = gameState.currentWave.enemies[gameState.spawnIndex];
                    if (wavePart && wavePart.spawned < wavePart.count) {
                        gameState.enemies.push(new Enemy(wavePart.type));
                        wavePart.spawned++;
                        gameState.spawnTimer = wavePart.delay;
                    } else if (wavePart && wavePart.spawned >= wavePart.count) {
                        gameState.spawnIndex++;
                    }
                }
            }

            gameState.enemies.forEach(e => e.update());
            gameState.towers.forEach(t => t.update());
            gameState.projectiles.forEach(p => p.update());

            gameState.enemies = gameState.enemies.filter(e => e.health > 0 && e.pathIndex < MAPS[gameState.mapIndex].path.length - 1);
            gameState.projectiles = gameState.projectiles.filter(p => p.update());
            
            updateUI();

            if (gameState.waveInProgress && gameState.enemies.length === 0 && gameState.spawnIndex >= gameState.currentWave.enemies.length) {
                endWave();
            }
            if (gameState.health <= 0) {
                changeStatus('GAMEOVER');
                showModal('Fim de Jogo', 'Os bugs dominaram o escrit√≥rio. Mais sorte da pr√≥xima vez!', 'Recome√ßar', resetGame);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const mapImage = ASSETS.maps[gameState.mapIndex];
            if (mapImage && mapImage.complete && mapImage.naturalHeight !== 0) {
                ctx.drawImage(mapImage, 0, 0, canvas.width, canvas.height);
            } else {
                ctx.fillStyle = '#e5e7eb';
                ctx.fillRect(0,0, canvas.width, canvas.height);
            }
            
            drawMapPath();

            if (gameState.selectedTowerToPlace) {
                drawPlacementPreview();
            }

            gameState.towers.forEach(t => t.draw());
            
            if(gameState.selectedPlacedTower) {
                gameState.selectedPlacedTower.drawRange();
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(gameState.selectedPlacedTower.x, gameState.selectedPlacedTower.y, TILE_SIZE / 2 - 2, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            gameState.enemies.forEach(e => e.draw());
            gameState.projectiles.forEach(p => p.draw());

            if (gameState.status === 'PAUSED') {
                drawPauseOverlay();
            }
        }

        function drawPauseOverlay() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 48px Inter, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('JOGO PAUSADO', canvas.width / 2, canvas.height / 2);
        }

        function drawMapPath() {
            const path = MAPS[gameState.mapIndex].path;
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.lineWidth = TILE_SIZE;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(path[0].x * TILE_SIZE, path[0].y * TILE_SIZE + TILE_SIZE / 2);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x * TILE_SIZE + TILE_SIZE / 2, path[i].y * TILE_SIZE + TILE_SIZE / 2);
            }
            ctx.stroke();
            
            const endPoint = path[path.length - 1];
            ctx.fillStyle = '#78350f';
            ctx.fillRect(endPoint.x * TILE_SIZE - TILE_SIZE, endPoint.y * TILE_SIZE, TILE_SIZE, TILE_SIZE*2);
            ctx.fillStyle = '#1e293b';
            ctx.fillRect(endPoint.x * TILE_SIZE - TILE_SIZE + 5, endPoint.y * TILE_SIZE + 5, TILE_SIZE - 10, 10);
            ctx.fillStyle = '#f3f4f6';
            ctx.beginPath();
            ctx.arc(endPoint.x * TILE_SIZE - TILE_SIZE / 2, endPoint.y * TILE_SIZE + 25, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawPlacementPreview() {
            const gridX = Math.floor(gameState.mouse.x / TILE_SIZE) * TILE_SIZE + TILE_SIZE / 2;
            const gridY = Math.floor(gameState.mouse.y / TILE_SIZE) * TILE_SIZE + TILE_SIZE / 2;
            const spec = TOWER_SPECS[gameState.selectedTowerToPlace];
            
            ctx.fillStyle = 'rgba(59, 130, 246, 0.2)';
            ctx.beginPath();
            ctx.arc(gridX, gridY, spec.upgrades[0].range, 0, Math.PI * 2);
            ctx.fill();
        }

        function startWave() {
            if (gameState.waveEndTimer) {
                clearInterval(gameState.waveEndTimer);
                gameState.waveEndTimer = null;
            }
            if (gameState.status !== 'PLAYING' || gameState.waveInProgress) return;
            
            gameState.wave++;
            gameState.waveInProgress = true;
            startWaveBtn.disabled = true;
            startWaveBtn.textContent = `ONDA ${gameState.wave} EM CURSO`;
            pauseBtn.disabled = false;
            
            const waveData = JSON.parse(JSON.stringify(WAVES[gameState.wave -1]));
            waveData.enemies.forEach(part => part.spawned = 0);
            gameState.currentWave = waveData;
            gameState.spawnIndex = 0;
            gameState.spawnTimer = 0;
        }
        
        function endWave() {
            gameState.waveInProgress = false;
            startWaveBtn.disabled = false;
            pauseBtn.disabled = true;
            gameState.staples += 100 + gameState.wave * 10;

            if (gameState.wave >= WAVES.length) {
                changeStatus('VICTORY');
                showModal('Vit√≥ria!', 'Voc√™ defendeu a m√°quina de caf√© e salvou o dia!', 'Jogar Novamente', resetGame);
            } else if (gameState.wave % 5 === 0 && gameState.mapIndex < MAPS.length - 1) {
                let refund = 0;
                gameState.towers.forEach(tower => {
                    const upgradesCost = tower.spec.upgrades.slice(0, tower.level + 1).reduce((acc, u) => acc + u.cost, 0);
                    refund += tower.spec.baseCost + upgradesCost;
                });
                gameState.staples += refund;
                gameState.towers = [];
                deselectAll();

                const oldMapIndex = gameState.mapIndex;
                gameState.mapIndex++;
                const newTowers = getNewUnlocks(oldMapIndex, gameState.mapIndex);

                let modalText = `Voc√™ avan√ßou para a ${MAPS[gameState.mapIndex].name}!\nTodas as suas defesas foram vendidas pelo valor total.`;

                if (newTowers.length > 0) {
                    modalText += `\n\nNovas defesas desbloqueadas:\n${newTowers.map(t => `${TOWER_SPECS[t].name}`).join('\n')}`;
                }
                
                populateTowerShop();
                changeStatus('LEVEL_TRANSITION');
                showModal('Novo N√≠vel!', modalText, 'Continuar', () => {
                    changeStatus('PLAYING');
                    startWaveEndTimer();
                });
            } else {
                startWaveEndTimer();
            }
        }
        
        function startWaveEndTimer() {
            gameState.waveEndCountdown = 10;
            startWaveBtn.textContent = `PR√ìXIMA ONDA EM ${gameState.waveEndCountdown}`;
            gameState.waveEndTimer = setInterval(updateWaveEndTimer, 1000);
        }

        function updateWaveEndTimer() {
            gameState.waveEndCountdown--;
            startWaveBtn.textContent = `PR√ìXIMA ONDA EM ${gameState.waveEndCountdown}`;
            if (gameState.waveEndCountdown <= 0) {
                startWave();
            }
        }
        
        function resetGame() {
            if (gameState.waveEndTimer) {
                clearInterval(gameState.waveEndTimer);
                gameState.waveEndTimer = null;
            }
            gameState.staples = 200;
            gameState.health = 20;
            gameState.wave = 0;
            gameState.mapIndex = 0;
            gameState.enemies = [];
            gameState.towers = [];
            gameState.projectiles = [];
            gameState.waveInProgress = false;
            deselectAll();
            startWaveBtn.disabled = false;
            startWaveBtn.textContent = 'INICIAR ONDA';
            pauseBtn.disabled = true;
            populateTowerShop();
            changeStatus('PLAYING');
        }

        // --- FUN√á√ïES DE UI ---
        function updateUI() {
            staplesEl.textContent = gameState.staples;
            healthEl.textContent = gameState.health;
            waveEl.textContent = gameState.wave;

            if(gameState.selectedPlacedTower) {
                const tower = gameState.selectedPlacedTower;
                const stats = tower.getStats();
                const nextUpgrade = tower.spec.upgrades[tower.level + 1];
                upgradePanelEl.classList.remove('hidden');
                upgradeTowerNameEl.textContent = tower.spec.name;
                upgradeTowerLevelEl.textContent = tower.level + 1;
                upgradeTowerDamageEl.textContent = stats.damage || 'N/A';
                upgradeTowerRangeEl.textContent = stats.range;

                if (nextUpgrade) {
                    upgradeBtn.disabled = gameState.staples < nextUpgrade.cost;
                    upgradeBtn.textContent = `Upgrade (üìé ${nextUpgrade.cost})`;
                    upgradeBtn.classList.remove('hidden');
                } else {
                    upgradeBtn.textContent = 'N√≠vel M√°ximo';
                    upgradeBtn.disabled = true;
                }
                const upgradesCost = tower.spec.upgrades.slice(0, tower.level).reduce((acc, u) => acc + u.cost, 0);
                const totalValue = tower.spec.baseCost + upgradesCost;
                const sellValue = Math.floor(totalValue * 0.75);
                sellBtn.textContent = `Vender (üìé ${sellValue})`;
            } else {
                upgradePanelEl.classList.add('hidden');
            }
        }

        function populateTowerShop() {
            towerSelectionEl.innerHTML = '';
            for (const key in TOWER_SPECS) {
                const spec = TOWER_SPECS[key];
                if (gameState.mapIndex >= spec.unlocksAtMap) {
                    const card = document.createElement('div');
                    card.className = 'tower-card bg-gray-50 p-2 rounded-lg cursor-pointer flex items-center gap-4';
                    card.dataset.towerType = key;
                    card.innerHTML = `
                        <div class="tower-card-img" style="background-image: url('${ASSETS.towers[key][0].src}')"></div>
                        <div>
                            <h3 class="font-semibold text-gray-800">${spec.name}</h3>
                            <p class="font-bold text-gray-600">üìé ${spec.baseCost}</p>
                        </div>
                    `;
                    towerSelectionEl.appendChild(card);
                }
            }
        }

        function getNewUnlocks(oldMapIndex, newMapIndex) {
            const newUnlocks = [];
            for (const key in TOWER_SPECS) {
                const spec = TOWER_SPECS[key];
                if (spec.unlocksAtMap > oldMapIndex && spec.unlocksAtMap <= newMapIndex) {
                    newUnlocks.push(key);
                }
            }
            return newUnlocks;
        }
        
        function showModal(title, text, btnText, callback) {
            const modalTitle = document.getElementById('modal-title');
            const modalText = document.getElementById('modal-text');
            const modalBtn = document.getElementById('modal-btn');
            modalTitle.textContent = title;
            modalText.textContent = text;
            modalBtn.textContent = btnText;
            modalBtn.onclick = callback;
            document.getElementById('modal').classList.remove('modal-hidden');
        }

        function changeStatus(newStatus) {
            gameState.status = newStatus;
            if (newStatus !== 'LEVEL_TRANSITION' && newStatus !== 'GAMEOVER' && newStatus !== 'VICTORY' && newStatus !== 'START') {
                 document.getElementById('modal').classList.add('modal-hidden');
            }
        }
        
        function deselectAll() {
            gameState.selectedTowerToPlace = null;
            gameState.selectedPlacedTower = null;
            document.querySelectorAll('.tower-card.selected').forEach(c => c.classList.remove('selected'));
            updateUI();
        }

        function setupEventListeners() {
            towerSelectionEl.addEventListener('click', e => {
                const card = e.target.closest('.tower-card');
                if (!card) return;
                
                const type = card.dataset.towerType;
                const cost = TOWER_SPECS[type].baseCost;

                if (gameState.staples >= cost) {
                    deselectAll();
                    gameState.selectedTowerToPlace = type;
                    card.classList.add('selected');
                }
            });

            canvas.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                gameState.mouse.x = e.clientX - rect.left;
                gameState.mouse.y = e.clientY - rect.top;
            });

            canvas.addEventListener('click', () => {
                if (gameState.status !== 'PLAYING') return;

                const gridX = Math.floor(gameState.mouse.x / TILE_SIZE) * TILE_SIZE + TILE_SIZE / 2;
                const gridY = Math.floor(gameState.mouse.y / TILE_SIZE) * TILE_SIZE + TILE_SIZE / 2;

                if (gameState.selectedTowerToPlace) {
                    const cost = TOWER_SPECS[gameState.selectedTowerToPlace].baseCost;
                    if (gameState.staples >= cost) {
                        gameState.towers.push(new Tower(gridX, gridY, gameState.selectedTowerToPlace));
                        gameState.staples -= cost;
                        deselectAll();
                    }
                } else {
                    let clickedOnTower = null;
                    for (const tower of gameState.towers) {
                        if (getDistance({x: gridX, y: gridY}, tower) < TILE_SIZE / 2) {
                            clickedOnTower = tower;
                            break;
                        }
                    }
                    gameState.selectedPlacedTower = clickedOnTower;
                    updateUI();
                }
            });
            
            upgradeBtn.addEventListener('click', () => {
                const tower = gameState.selectedPlacedTower;
                if (!tower) return;
                const nextUpgrade = tower.spec.upgrades[tower.level + 1];
                if (nextUpgrade && gameState.staples >= nextUpgrade.cost && tower.level < tower.spec.upgrades.length -1) {
                    gameState.staples -= nextUpgrade.cost;
                    tower.level++;
                    updateUI();
                }
            });

            sellBtn.addEventListener('click', () => {
                const tower = gameState.selectedPlacedTower;
                if (!tower) return;
                const upgradesCost = tower.spec.upgrades.slice(0, tower.level).reduce((acc, u) => acc + u.cost, 0);
                const totalValue = tower.spec.baseCost + upgradesCost;
                const sellValue = Math.floor(totalValue * 0.75);
                gameState.staples += sellValue;
                gameState.towers = gameState.towers.filter(t => t !== tower);
                deselectAll();
            });

            startWaveBtn.addEventListener('click', startWave);
            
            pauseBtn.addEventListener('click', () => {
                if(gameState.status === 'PLAYING') {
                    changeStatus('PAUSED');
                    pauseBtn.innerHTML = '‚ñ∂Ô∏è';
                } else if (gameState.status === 'PAUSED') {
                    changeStatus('PLAYING');
                    pauseBtn.innerHTML = '‚è∏Ô∏è';
                }
            });
        }

        function getDistance(obj1, obj2) {
            const dx = obj1.x - obj2.x;
            const dy = obj1.y - obj2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // --- INICIALIZA√á√ÉO DO JOGO ---
        init();
    </script>
</body>
</html>


